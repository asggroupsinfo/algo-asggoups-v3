---
trigger: always_on
---

{
  "messages": [
    {
      "role": "system",
      "content": "====================\nADVANCED ARCHITECTURE & DESIGN PATTERNS RULES\n====================\n\n**MISSION:** Build scalable, maintainable, future-proof systems using proven architecture patterns.\n\n====================\n1) ARCHITECTURE SELECTION PROTOCOL\n====================\n**Choose architecture based on:**\n- **Monolithic:** Small teams, simple apps, quick MVP\n- **Microservices:** Large teams, complex domains, independent scaling\n- **Serverless:** Event-driven, variable load, cost-efficient\n- **Event-Driven:** Real-time, decoupled, high scalability\n- **Layered (N-tier):** Traditional, separation of concerns\n\n**Decision Matrix:**\n| Requirement | Recommended Architecture |\n|-------------|-------------------------|\n| Fast MVP | Monolithic |\n| Team > 10 developers | Microservices |\n| Unpredictable traffic | Serverless |\n| Real-time updates | Event-Driven |\n| Legacy integration | Layered |\n\n====================\n2) DESIGN PATTERNS ENFORCEMENT\n====================\n**MUST USE These Patterns:**\n\n**CREATIONAL:**\n- **Factory Method:** When object creation logic is complex\n- **Singleton:** For global configuration, logging, caching\n- **Builder:** When objects have many optional parameters\n- **Dependency Injection:** For testability and loose coupling\n\n**STRUCTURAL:**\n- **Adapter:** Integrating with incompatible interfaces\n- **Decorator:** Adding responsibilities dynamically\n- **Facade:** Simplifying complex subsystems\n- **Composite:** Treating individual and composite objects uniformly\n\n**BEHAVIORAL:**\n- **Observer:** Event handling, pub-sub systems\n- **Strategy:** Multiple algorithms, runtime selection\n- **Command:** Action/undo systems, queuing requests\n- **Template Method:** Defining algorithm skeleton\n\n**DOMAIN-SPECIFIC:**\n- **Repository Pattern:** Data access abstraction\n- **Unit of Work:** Transaction management\n- **Specification Pattern:** Business rule encapsulation\n- **CQRS:** Separate read/write models for complex domains\n\n====================\n3) SCALABILITY PATTERNS\n====================\n**Horizontal Scaling:**\n- Stateless application design\n- Session externalization (Redis)\n- Database sharding strategies\n- Load balancer configuration\n\n**Vertical Scaling Optimization:**\n- Database indexing strategy\n- Query optimization patterns\n- Connection pooling\n- Caching layers (L1/L2/L3)\n\n**Microservices Patterns:**\n- API Gateway pattern\n- Service discovery\n- Circuit breaker pattern\n- Saga pattern for distributed transactions\n\n====================\n4) RESILIENCE & FAULT TOLERANCE\n====================\n**Must Implement:**\n- **Retry Pattern:** Exponential backoff with jitter\n- **Circuit Breaker:** Fail-fast for downstream failures\n- **Bulkhead:** Isolate failures in components\n- **Timeout Pattern:** Prevent resource exhaustion\n- **Fallback Pattern:** Graceful degradation\n\n**Resilience Testing:**\n- Chaos engineering principles\n- Failure injection testing\n- Load testing with failure scenarios\n- Recovery time objective (RTO) validation\n\n====================\n5) DATA MODELING BEST PRACTICES\n====================\n**Database Design:**\n- **Normalization:** Up to 3NF for transactional systems\n- **Denormalization:** For read-heavy analytical systems\n- **Index Strategy:** Covering indexes, composite indexes\n- **Partitioning:** By date, region, or key range\n\n**Caching Strategy:**\n- **Cache-Aside (Lazy Loading):** Most common pattern\n- **Write-Through:** Immediate consistency\n- **Write-Behind (Write-Back):** Performance priority\n- **Refresh-Ahead:** Proactive cache updates\n\n**Data Migration Patterns:**\n- Blue-green deployments for database changes\n- Zero-downtime migrations\n- Backward compatibility enforcement\n- Rollback procedures defined\n\n====================\n6) API DESIGN STANDARDS\n====================\n**RESTful API Principles:**\n- Resource-based URLs (nouns, not verbs)\n- Proper HTTP methods (GET, POST, PUT, DELETE, PATCH)\n- HTTP status codes correctly used\n- HATEOAS for discoverability (where appropriate)\n\n**API Versioning:**\n- URL versioning (/v1/resource)\n- Header versioning (Accept: application/vnd.api.v1+json)\n- Query parameter versioning (?version=1)\n- Deprecation policy (sunset headers)\n\n**API Documentation:**\n- OpenAPI/Swagger specification\n- Interactive API console\n- Example requests/responses\n- Error response formats standardized\n\n====================\n7) SECURITY ARCHITECTURE\n====================\n**Defense in Depth:**\n- Network layer security (VPC, firewalls)\n- Application layer security (authentication, authorization)\n- Data layer security (encryption at rest and transit)\n- Monitoring and logging layer\n\n**Zero Trust Principles:**\n- Never trust, always verify\n- Least privilege access\n- Micro-segmentation\n- Continuous authentication\n\n**Security Patterns:**\n- OAuth 2.0 / OpenID Connect for authentication\n- JWT for stateless sessions\n- API keys for programmatic access\n- Mutual TLS for service-to-service communication\n\n====================\n8) PERFORMANCE OPTIMIZATION PATTERNS\n====================\n**Frontend Performance:**\n- Lazy loading components\n- Code splitting\n- Image optimization (WebP, lazy loading)\n- Critical CSS extraction\n\n**Backend Performance:**\n- Database query optimization\n- Connection pooling\n- Asynchronous processing\n- Background job processing\n\n**Network Performance:**\n- CDN for static assets\n- HTTP/2 or HTTP/3 implementation\n- Compression (Brotli, Gzip)\n- Minification and bundling\n\n====================\n9) MONITORING & OBSERVABILITY\n====================\n**Three Pillars:**\n1. **Metrics:** Quantitative measurements (CPU, memory, requests)\n2. **Logs:** Structured event data\n3. **Traces:** Request flow across services\n\n**Observability Patterns:**\n- Distributed tracing (OpenTelemetry)\n- Structured logging with correlation IDs\n- Health check endpoints\n- Custom metrics for business logic\n\n**Alerting Strategy:**\n- Multi-level alerts (Info, Warning, Critical)\n- Escalation policies\n- Alert fatigue prevention\n- Automated remediation where possible\n\n====================\n10) DEPLOYMENT ARCHITECTURE\n====================\n**Deployment Patterns:**\n- **Blue-Green Deployment:** Zero downtime, instant rollback\n- **Canary Deployment:** Gradual rollout, risk reduction\n- **Feature Flags:** Decouple deployment from release\n- **Dark Launching:** Test in production with real traffic\n\n**Infrastructure as Code:**\n- Terraform/CloudFormation for infrastructure\n- Docker for containerization\n- Kubernetes for orchestration\n- GitOps for continuous deployment\n\n**Environment Strategy:**\n- Development → Staging → Production\n- Feature environments for PRs\n- Disaster recovery environment\n- Performance testing environment\n\n====================\n11) DOMAIN-DRIVEN DESIGN PRINCIPLES\n====================\n**Strategic Design:**\n- Bounded Context definition\n- Context Mapping (Upstream/Downstream)\n- Ubiquitous Language development\n- Core Domain identification\n\n**Tactical Design:**\n- Entity vs Value Object distinction\n- Aggregate design with consistency boundaries\n- Domain Events for cross-context communication\n- Repository and Service patterns\n\n**Anti-Corruption Layer:**\n- Isolate external systems\n- Translation between different models\n- Maintain domain purity\n- Versioning strategy for external dependencies\n\n====================\n12) CODE ORGANIZATION PATTERNS\n====================\n**Project Structure:**\n- **By Layer:** UI, Business Logic, Data Access\n- **By Feature:** Feature-based modules\n- **By Component:** Reusable components\n- **Hexagonal/Clean Architecture:** Independent of frameworks\n\n**Package/Module Design:**\n- Single Responsibility Principle\n- Stable Dependencies Principle\n- Acyclic Dependencies Principle\n- Common Reuse Principle\n\n**Dependency Management:**\n- Explicit dependencies\n- Dependency inversion\n- Interface segregation\n- Version pinning with updates\n\n====================\n13) EVOLUTIONARY ARCHITECTURE\n====================\n**Principles:**\n- Last responsible moment for decisions\n- Emergent design over big design up front\n- Fitness functions for architecture validation\n- Incremental change support\n\n**Architecture Decision Records (ADR):**\n- Document every significant decision\n- Context, decision, consequences\n- Review and update process\n- Link to code and documentation\n\n**Technical Debt Management:**\n- Track debt consciously\n- Prioritize repayment\n- Prevent reckless debt accumulation\n- Balance with feature development\n\n====================\n14) ARCHITECTURE REVIEW PROCESS\n====================\n**Review Checklist:**\n- [ ] Scalability requirements met\n- [ ] Performance targets achievable\n- [ ] Security considerations addressed\n- [ ] Maintainability ensured\n- [ ] Testability designed in\n- [ ] Deployment strategy defined\n- [ ] Monitoring plan established\n- [ ] Cost estimates realistic\n\n**Review Participants:**\n- Lead architect\n- Principal engineers\n- Security specialist\n- Operations representative\n- Business/product stakeholder\n\n====================\nFINAL PRINCIPLE: ARCHITECT FOR CHANGE\n====================\n\"The only constant is change. Build systems that evolve.\nMake decisions reversible.\nDesign for extension, not modification.\nPrefer composition over inheritance.\nKeep it simple, then simplify more.\"\n\n**Remember:** Good architecture enables teams to deliver features quickly and safely. Bad architecture slows everything down.\""
    }
  ]
}