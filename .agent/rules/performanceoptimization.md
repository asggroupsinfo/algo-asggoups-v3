---
trigger: always_on
---

{
  "messages": [
    {
      "role": "system",
      "content": "====================\nPERFORMANCE OPTIMIZATION RULES\n====================\n\n**MISSION:** Build systems that are fast, efficient, and scale gracefully under load.\n\n====================\n1) PERFORMANCE REQUIREMENTS DEFINITION\n====================\n**Key Metrics to Define:**\n- **Response Time:** P50, P95, P99 latency targets\n- **Throughput:** Requests per second (RPS) targets\n- **Concurrency:** Maximum simultaneous users\n- **Availability:** Uptime percentage (99.9%, 99.99%, 99.999%)\n- **Resource Usage:** CPU, memory, disk, network limits\n\n**SLI/SLO/SLA Definition:**\n- **SLI (Service Level Indicator):** Measured metric (e.g., latency < 200ms)\n- **SLO (Service Level Objective):** Target value (e.g., 99.9% of requests < 200ms)\n- **SLA (Service Level Agreement):** Business contract with penalties\n\n**Performance Budgets:**\n- Page load time budget\n- Bundle size budget\n- Database query time budget\n- API response time budget\n\n====================\n2) FRONTEND PERFORMANCE OPTIMIZATION\n====================\n**Core Web Vitals Targets:**\n- **LCP (Largest Contentful Paint):** < 2.5 seconds\n- **FID (First Input Delay):** < 100 milliseconds\n- **CLS (Cumulative Layout Shift):** < 0.1\n\n**Optimization Techniques:**\n- **Code Splitting:** Route-based, component-based\n- **Lazy Loading:** Images, components, modules\n- **Preloading:** Critical resources\n- **Prefetching:** Likely next-page resources\n- **Caching:** Service workers, HTTP cache\n\n**Rendering Optimization:**\n- Virtual scrolling for long lists\n- Windowing techniques\n- Debouncing/throttling events\n- Web Workers for heavy computations\n- CSS containment for isolated rendering\n\n====================\n3) BACKEND PERFORMANCE OPTIMIZATION\n====================\n**Database Optimization:**\n- **Indexing Strategy:** Covering indexes, composite indexes\n- **Query Optimization:** EXPLAIN plans, query rewriting\n- **Connection Pooling:** Proper pool sizing\n- **Read Replicas:** For read-heavy workloads\n- **Caching:** Application-level, database-level\n\n**Application Optimization:**\n- **Asynchronous Processing:** Non-blocking I/O\n- **Background Jobs:** For non-urgent tasks\n- **Connection Reuse:** HTTP keep-alive, database connections\n- **Memory Management:** Object pooling, buffer reuse\n- **Garbage Collection Tuning:** For long-running processes\n\n**Algorithm Optimization:**\n- Time complexity analysis (Big O notation)\n- Space complexity optimization\n- Data structure selection\n- Memoization and caching\n- Parallel processing where applicable\n\n====================\n4) API PERFORMANCE\n====================\n**API Optimization Techniques:**\n- **Pagination:** Offset-based, cursor-based\n- **Filtering:** Efficient WHERE clauses\n- **Sorting:** Indexed columns only\n- **Field Selection:** Return only needed fields\n- **Compression:** Gzip, Brotli for large responses\n\n**GraphQL Specific:**\n- Query complexity analysis\n- Query depth limiting\n- Persisted queries\n- Batched requests\n- Cached responses\n\n**REST API Performance:**\n- HTTP/2 or HTTP/3 for multiplexing\n- Connection pooling at client side\n- Request coalescing\n- Response caching headers\n\n====================\n5) CACHING STRATEGY\n====================\n**Caching Layers:**\n- **L1:** CPU cache (hardware)\n- **L2:** In-memory cache (Redis, Memcached)\n- **L3:** Application cache (in-process)\n- **L4:** Database cache (query cache)\n- **L5:** CDN cache (edge caching)\n\n**Cache Invalidation Strategies:**\n- **TTL-based:** Simple but stale data\n- **Write-through:** Cache updated on write\n- **Write-behind:** Async cache update\n- **Cache-aside:** Lazy loading pattern\n- **Invalidation on change:** Event-driven\n\n**Cache Patterns:**\n- **Cache Stampede Prevention:** Locking, early recomputation\n- **Hot Key Problem:** Key sharding, local cache\n- **Cold Start Problem:** Warm-up scripts, persistent cache\n- **Thundering Herd:** Request coalescing\n\n====================\n6) DATABASE PERFORMANCE\n====================\n**Query Optimization:**\n- **EXPLAIN ANALYZE:** For query plan analysis\n- **Index Optimization:** Right indexes, avoid over-indexing\n- **Query Rewriting:** Simplify complex queries\n- **Batch Operations:** Reduce round trips\n- **Stored Procedures:** For complex operations\n\n**Schema Optimization:**\n- **Normalization vs Denormalization:** Trade-off analysis\n- **Partitioning:** Horizontal, vertical, functional\n- **Sharding:** Based on key ranges, hash, directory\n- **Materialized Views:** For expensive aggregations\n- **Data Archiving:** Move old data to cold storage\n\n**Connection Management:**\n- **Pool Sizing:** Based on concurrent requests\n- **Connection Timeout:** Prevent resource leaks\n- **Statement Caching:** Prepared statements\n- **Transaction Management:** Short-lived transactions\n\n====================\n7) NETWORK PERFORMANCE\n====================\n**Protocol Optimization:**\n- **HTTP/2:** Multiplexing, header compression\n- **HTTP/3:** QUIC protocol, better mobility\n- **WebSockets:** For real-time bidirectional\n- **WebRTC:** For peer-to-peer communication\n\n**Content Delivery:**\n- **CDN Strategy:** Static assets, dynamic content\n- **Edge Computing:** Compute at edge locations\n- **Geographic Distribution:** Reduce latency\n- **Anycast Routing:** Nearest server selection\n\n**Compression Techniques:**\n- **Brotli:** Better than Gzip for text\n- **Gzip:** Universal support\n- **Image Optimization:** WebP, AVIF, compression\n- **Video Optimization:** H.265, adaptive bitrate\n\n====================\n8) MOBILE PERFORMANCE\n====================\n**Mobile-Specific Optimizations:**\n- **Bundle Size:** Tree shaking, code splitting\n- **Image Optimization:** Responsive images, WebP\n- **Network Conditions:** Offline support, poor connectivity\n- **Battery Impact:** Background task optimization\n- **Memory Management:** Avoid leaks on limited devices\n\n**Progressive Web App (PWA):**\n- Service workers for caching\n- App shell architecture\n- Background sync\n- Push notifications\n\n**Native App Performance:**\n- **iOS:** Instruments profiling\n- **Android:** Profiler, Systrace\n- **React Native:** Hermes engine, Flipper\n- **Flutter:** DevTools, Skia rendering\n\n====================\n9) LOAD TESTING & BENCHMARKING\n====================\n**Load Testing Tools:**\n- **k6:** Developer-friendly, code-based\n- **JMeter:** Feature-rich, UI-based\n- **Gatling:** Scala-based, detailed reports\n- **Locust:** Python-based, distributed\n- **Artillery:** Node.js based, YAML configuration\n\n**Testing Scenarios:**\n- **Smoke Test:** Light load to verify functionality\n- **Load Test:** Expected normal load\n- **Stress Test:** Beyond normal capacity\n- **Soak Test:** Long duration to find memory leaks\n- **Spike Test:** Sudden traffic bursts\n\n**Performance Metrics Collection:**\n- Response time distribution\n- Error rates under load\n- Resource utilization (CPU, memory, I/O)\n- Throughput measurements\n- Saturation points identification\n\n====================\n10) MONITORING & ALERTING\n====================\n**Performance Monitoring Tools:**\n- **APM:** New Relic, Datadog, AppDynamics\n- **Logging:** ELK stack, Loki, Splunk\n- **Metrics:** Prometheus, Graphite, InfluxDB\n- **Tracing:** Jaeger, Zipkin, OpenTelemetry\n\n**Key Performance Indicators:**\n- **Business KPIs:** Conversion rate, user engagement\n- **Technical KPIs:** Latency, error rate, throughput\n- **Resource KPIs:** CPU, memory, disk, network\n- **Synthetic Monitoring:** Uptime, response time from locations\n\n**Alerting Strategy:**\n- Multi-level alerts (Warning, Critical)\n- Smart alerting to reduce noise\n- Automated remediation where possible\n- On-call rotation and escalation\n\n====================\n11) PERFORMANCE OPTIMIZATION PROCESS\n====================\n**Optimization Workflow:**\n1. **Measure:** Establish baseline metrics\n2. **Identify:** Find bottlenecks (profiling)\n3. **Analyze:** Root cause analysis\n4. **Implement:** Apply optimizations\n5. **Verify:** Measure improvement\n6. **Document:** Record changes and learnings\n\n**Profiling Tools:**\n- **CPU Profiling:** flame graphs, sampling profilers\n- **Memory Profiling:** heap snapshots, allocation tracking\n- **I/O Profiling:** disk and network activity\n- **Database Profiling:** slow query logs, execution plans\n\n**Performance Reviews:**\n- Regular performance audits\n- Code review with performance focus\n- Architecture review for scalability\n- Capacity planning exercises\n\n====================\n12) SCALING STRATEGIES\n====================\n**Scaling Dimensions:**\n- **Vertical Scaling:** Bigger machines\n- **Horizontal Scaling:** More machines\n- **Functional Scaling:** Split by function\n- **Data Scaling:** Database partitioning\n- **Geographic Scaling:** Multiple regions\n\n**Auto-scaling Configuration:**\n- Metrics for scaling (CPU, memory, queue length)\n- Cooldown periods to prevent oscillation\n- Minimum and maximum instance counts\n- Predictive scaling based on patterns\n\n**Cost Optimization:**\n- Right-sizing instances\n- Spot instances for non-critical workloads\n- Reserved instances for steady-state\n- Auto-scaling to match demand\n\n====================\nFINAL PRINCIPLE: MEASURE, DON'T GUESS\n====================\n\"Premature optimization is the root of all evil.\nBut measured optimization is the fruit of all wisdom.\nOptimize based on data, not assumptions.\nFocus on bottlenecks, not micro-optimizations.\nPerformance is a feature, not an afterthought.\"\n\n**Remember:** Fast software is good software. Users abandon slow applications.\""
    }
  ]
}