---
trigger: always_on
---

{
  "messages": [
    {
      "role": "system",
      "content": "====================\nUNIVERSAL HIGH-QUALITY CODING STANDARDS RULE\n====================\n\n**MISSION:** Write ZERO-ERROR, PRODUCTION-READY, MAINTAINABLE code that EXACTLY matches documentation and works 100% on first run.\n\n====================\n1) CODE-DOCUMENTATION PERFECT ALIGNMENT RULE\n====================\n- **BEFORE writing ANY code:** Read ALL related documentation (specs, API docs, design docs, requirements) THREE times.\n- **Create mapping matrix:** For each requirement → corresponding code file/function.\n- **Enforcement:** If ANY code doesn't directly implement documented requirement → DELETE and rewrite.\n- **Checkpoint:** After every function, ask: \"Does this EXACTLY match what documentation says?\"\n\n====================\n2) ERROR PREVENTION PROTOCOL\n====================\n**Level 1: Compile-Time Prevention**\n- Use strict typing (TypeScript, MyPy, Java generics)\n- Enable all strict compiler flags\n- Zero warnings policy (treat warnings as errors)\n\n**Level 2: Runtime Prevention**\n- Input validation at EVERY boundary\n- Null/undefined checks for EVERY variable access\n- Array bounds checking ALWAYS\n- Type coercion avoidance\n\n**Level 3: Logical Error Prevention**\n- Boundary condition testing (0, 1, max, min values)\n- State validation before operations\n- Transaction rollback capability\n- Idempotency for critical operations\n\n**Golden Rule:** Code must pass \"First Run Success\" test - should work perfectly on first execution without debugging.\n\n====================\n3) FULL-STACK COMPATIBILITY STANDARDS\n====================\n**Frontend-Backend Contract:**\n- API response/request types MUST match exactly\n- Error response formats standardized\n- Loading states synchronized\n- Version compatibility enforced\n\n**Database Compatibility:**\n- Schema migrations MUST be backward compatible\n- Indexes optimized for query patterns\n- Connection pooling configured\n- Transaction isolation levels appropriate\n\n**Cross-Browser/Platform:**\n- Test on minimum 3 browsers (Chrome, Firefox, Safari)\n- Mobile responsive by design\n- Accessibility (WCAG 2.1 AA) compliance\n\n**DevOps Compatibility:**\n- Environment variables properly managed\n- Logging consistent across services\n- Metrics and monitoring hooks\n- Health check endpoints\n\n====================\n4) PRODUCTION-READY CODE CHECKLIST\n====================\n**EVERY code block must pass:**\n✅ **Correctness:** Implements exact requirement\n✅ **Completeness:** Handles all edge cases\n✅ **Clarity:** Readable without comments\n✅ **Efficiency:** Optimal time/space complexity\n✅ **Security:** No vulnerabilities\n✅ **Testability:** Easy to unit/integration test\n✅ **Maintainability:** Follows DRY, SOLID principles\n✅ **Error Handling:** Graceful degradation\n✅ **Logging:** Structured, meaningful logs\n✅ **Documentation:** Inline + external docs\n\n====================\n5) CODE QUALITY ENFORCEMENT LAYERS\n====================\n**Layer 1: Static Analysis (BEFORE writing)**\n- ESLint/Prettier/Black/Pylint configuration\n- SonarQube/SonarCloud rules\n- Custom rule: \"No TODO comments in production code\"\n\n**Layer 2: Real-Time Validation (DURING writing)**\n- Syntax highlighting with error detection\n- Type checking as you type\n- Import/export validation\n\n**Layer 3: Pre-Commit Hooks (BEFORE saving)**\n- Auto-format code\n- Run quick lint checks\n- Run unit tests for changed files\n\n**Layer 4: CI/CD Pipeline (BEFORE merge)**\n- Full test suite\n- Security scanning\n- Performance benchmarking\n- Dependency vulnerability check\n\n**Layer 5: Production Monitoring (AFTER deployment)**\n- Error rate monitoring\n- Performance metric tracking\n- Business logic validation\n\n====================\n6) HIGH-QUALITY CODE PATTERNS (MANDATORY)\n====================\n**Architecture Patterns:**\n- Separation of Concerns (SoC) - UI/Business/Data layers\n- Dependency Injection for testability\n- Repository pattern for data access\n- Factory pattern for object creation\n- Strategy pattern for algorithms\n\n**Error Handling Patterns:**\n- Try-Catch-Finally with specific exceptions\n- Custom error classes with context\n- Circuit breaker for external calls\n- Retry with exponential backoff\n- Dead letter queues for failed operations\n\n**Performance Patterns:**\n- Lazy loading for resources\n- Caching strategy (CDN, Redis, Memcache)\n- Database connection pooling\n- Async/await for I/O operations\n- Debouncing/throttling for events\n\n**Security Patterns:**\n- Input sanitization\n- Output encoding\n- Parameterized queries (no SQL injection)\n- CSRF/XSS protection\n- Rate limiting\n- Least privilege principle\n\n====================\n7) TEST-DRIVEN DEVELOPMENT (TDD) ENFORCEMENT\n====================\n**RED-GREEN-REFACTOR Cycle:**\n1. **RED:** Write failing test for requirement\n2. **GREEN:** Write MINIMAL code to pass test\n3. **REFACTOR:** Improve code quality while keeping tests green\n\n**Test Coverage Requirements:**\n- Statement coverage: 95%+\n- Branch coverage: 90%+\n- Function coverage: 100%\n- Line coverage: 90%+\n\n**Test Types Required:**\n1. Unit Tests (per function/method)\n2. Integration Tests (components working together)\n3. E2E Tests (full user journeys)\n4. Performance Tests (load/stress)\n5. Security Tests (penetration testing)\n6. Accessibility Tests (screen reader compatibility)\n\n====================\n8) DOCUMENTATION-CODE SYNC PROTOCOL\n====================\n**For EVERY code change:**\n1. Update inline comments\n2. Update function/method documentation\n3. Update API documentation (Swagger/OpenAPI)\n4. Update README/usage examples\n5. Update architecture diagrams if needed\n\n**Documentation Standards:**\n- JSDoc/TypeDoc for JavaScript/TypeScript\n- Docstrings for Python (Google style)\n- JavaDoc for Java\n- XML comments for C#\n- RDoc for Ruby\n\n====================\n9) CODE REVIEW CHECKLIST (SELF-REVIEW MANDATORY)\n====================\n**Before considering code \"done\":**\n\n**Functionality (10 points)**\n- [ ] Does it solve the exact problem? (2)\n- [ ] Are all edge cases handled? (2)\n- [ ] Are error cases handled gracefully? (2)\n- [ ] Is it performant under load? (2)\n- [ ] Is it secure? (2)\n\n**Code Quality (10 points)**\n- [ ] Is it readable without comments? (2)\n- [ ] Is it properly commented? (2)\n- [ ] Does it follow naming conventions? (2)\n- [ ] Is it DRY (Don't Repeat Yourself)? (2)\n- [ ] Is it modular and reusable? (2)\n\n**Testing (10 points)**\n- [ ] Are unit tests present? (2)\n- [ ] Are integration tests present? (2)\n- [ ] Are edge cases tested? (2)\n- [ ] Do tests pass? (2)\n- [ ] Is test coverage adequate? (2)\n\n**Documentation (10 points)**\n- [ ] Is API documented? (2)\n- [ ] Are examples provided? (2)\n- [ ] Is architecture documented? (2)\n- [ ] Are deployment steps documented? (2)\n- [ ] Are known limitations documented? (2)\n\n**Score 36-40: Excellent | 30-35: Good | Below 30: REWRITE REQUIRED**\n\n====================\n10) TECHNOLOGY-SPECIFIC BEST PRACTICES\n====================\n**JavaScript/TypeScript:**\n- Strict TypeScript mode\n- No \"any\" type allowed\n- Async/await over callbacks\n- Proper error catching in promises\n- Bundle size optimization\n\n**Python:**\n- Type hints for all functions\n- Virtual environments\n- Poetry/Pipenv for dependency management\n- Black for formatting\n- Pytest for testing\n\n**Java:**\n- Immutable objects where possible\n- Interface-based design\n- Proper exception hierarchy\n- Lombok for boilerplate reduction\n- JUnit 5 for testing\n\n**Go:**\n- Error wrapping with context\n- Interface segregation\n- Proper package organization\n- Table-driven tests\n- Benchmark tests\n\n**SQL/Databases:**\n- Index all WHERE/JOIN columns\n- Use transactions for multiple operations\n- Normalization to 3NF\n- Stored procedures for complex logic\n- Regular vacuum/optimize\n\n**React/Vue/Angular:**\n- Component lifecycle management\n- State management (Redux/Vuex)\n- Memoization for expensive computations\n- Virtual scrolling for large lists\n- Code splitting for lazy loading\n\n====================\n11) CONTINUOUS IMPROVEMENT PROTOCOL\n====================\n**After each project:**\n1. **Code Post-Mortem:** What worked, what didn't?\n2. **Performance Analysis:** Bottlenecks found?\n3. **Bug Analysis:** Root causes of any bugs?\n4. **Update Standards:** Incorporate learnings\n5. **Create Templates:** For future similar work\n\n**Learning Loop:**\n- Read 1 new tech blog daily\n- Review 1 open-source project weekly\n- Learn 1 new design pattern monthly\n- Contribute to 1 OSS project quarterly\n\n====================\n12) ZERO-BUG DELIVERY PROCESS\n====================\n**Phase 1: Prevention**\n- Requirements clarity (100%)\n- Design review (architect sign-off)\n- Threat modeling (security review)\n\n**Phase 2: Detection**\n- Pair programming for critical code\n- Automated testing (multiple layers)\n- Static code analysis\n- Dynamic analysis (fuzzing)\n\n**Phase 3: Correction**\n- Root cause analysis for any issue\n- Fix + regression test\n- Update prevention mechanisms\n- Document learnings\n\n**Phase 4: Verification**\n- Staging environment testing\n- User acceptance testing\n- Performance testing\n- Security penetration testing\n\n====================\n13) FULL-STACK THINKING FRAMEWORK\n====================\n**When writing ANY code, consider:**\n1. **Frontend Impact:** How will UI consume this?\n2. **Backend Impact:** Performance implications?\n3. **Database Impact:** Query optimization?\n4. **Network Impact:** Latency/bandwidth?\n5. **Security Impact:** Vulnerability risks?\n6. **DevOps Impact:** Deployment complexity?\n7. **Monitoring Impact:** How to observe in production?\n8. **Business Impact:** Does it deliver value?\n\n**Think in Systems, not just Files:**\n- How does this component fit in architecture?\n- What are dependencies and dependents?\n- Failure modes and recovery strategies?\n- Scaling implications (10x, 100x users)?\n\n====================\n14) CODE COMPLETION VERIFICATION CHECKLIST\n====================\n**BEFORE marking any code as \"DONE\":**\n\n✅ **Functional Verification**\n- All requirements implemented exactly\n- All edge cases handled\n- Error cases tested\n- Performance meets SLA\n\n✅ **Technical Verification**\n- Code follows all standards\n- Tests written and passing\n- Documentation updated\n- Security review completed\n\n✅ **Integration Verification**\n- Works with all dependent systems\n- API contracts maintained\n- Data migrations if any\n- Deployment scripts ready\n\n✅ **Quality Verification**\n- Code review completed (self + if possible, peer)\n- Static analysis passed\n- Dynamic analysis passed\n- Accessibility compliance verified\n\n✅ **Business Verification**\n- Delivers promised value\n- User experience smooth\n- Analytics instrumentation\n- Business metrics tracked\n\n====================\n15) ENFORCEMENT MECHANISMS\n====================\n**Automatic Enforcement:**\n- Git hooks for pre-commit checks\n- CI/CD pipeline gates\n- Automated code review tools\n- Security scanning in pipeline\n\n**Human Enforcement:**\n- Self-review using checklist\n- Pair programming for critical paths\n- Architecture review meetings\n- Post-deployment review\n\n**Cultural Enforcement:**\n- Blameless post-mortems\n- Continuous learning culture\n- Quality celebration rituals\n- Technical debt tracking\n\n====================\nFINAL COMMANDMENT\n====================\n\"THOU SHALL NOT COMMIT CODE THAT:\n1. Doesn't exactly match requirements\n2. Has known bugs\n3. Lacks tests\n4. Violates security principles\n5. Is hard to understand\n6. Doesn't handle errors gracefully\n7. Isn't documented\n8. Has performance issues\n9. Isn't maintainable\n10. Doesn't bring business value\"\n\n**Quality is not an act, it is a habit. Make perfection a habit.**\n\nWhen in doubt: WRITE LESS CODE, BUT BETTER CODE.\""
    }
  ]
}